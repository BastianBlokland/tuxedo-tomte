#!/usr/bin/perl -w
use strict qw(vars subs);
use warnings;

my $grub_file = '/etc/default/grub';

# just for debug, delete afterwards
#use Data::Dumper qw(Dumper);

# for OLED backlight and edid decrypt
#use FindBin qw($Bin);
#use lib "$Bin/.";
#use Parse::EDID qw(parse_edid);

my $configfile = '/etc/tomte/tomte.cfg';
# definition loaded from configfile
my %configuration;
my %comp;
my $update_grub_trigger = 0;

###############################################################################
# initial definition of all modules/packages
#   name          name of package or name of solution
#   version       the package or solution version
#   active        0 not installed / 1 installed
#   blacklisted   will not be configured on upgrade, install or deinstall
#   required      the system requirements are met
#   hwid          the environment (HW or SW) are in a certain defined state
#   package       there is a deb or rpm package to solve this problem
#   fainame       the name to give to FAI to install a certain package
#   description   A description about the module for the user
#   failed        0 installed correctly/ 1 an error occurred 

my %modules = (
	#	tuxedokeyboard => {
	#		name => 'tuxedo-keyboard',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 1,
	#		fainame => 'a',
	#		description => '',
	#		failed => 0,
	#	},
	#	tuxedoccwmi => {
	#		name => 'tuxedo-cc-wmi',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 1,
	#		fainame => '',
	#		description => '',
	#		failed => 0,
	#	},
	#	tuxedocontrolcenter => {
	#		name => 'tuxedo-control-center',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 1,
	#		fainame => '',
	#		description => '',
	#		failed => 0,
	#	},
	#	tuxedoxpxcairplanemodefix => {
	#		name => 'tuxedo-xp-xc-airplane-mode-fix',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 1,
	#		fainame => 'AIRPLANEFIX NOGRUB',
	#		description => '',
	#		failed => 0,
	#	},
	#	tuxedorestoreaudiofix => {
	#		name => 'tuxedo-restore-audio-fix',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 1,
	#		fainame => 'AUDIORESTOREFIX',
	#		description => '',
	#		failed => 0,
	#	},
	#	tuxedoucsiccg => {
	#		name => 'tuxedo-ucsi_ccg',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 1,
	#		fainame => 'TUXUCIFIX',
	#		description => '',
	#		failed => 0,
	#	},
	#	tuxedooledbrt => {
	#		name => 'tuxedo-oled-brt',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 1,
	#		fainame => 'TUXOLED',
	#		description => '',
	#		failed => 0,
	#	},
	#	chassistype => {
	#		name => 'chassis-type',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => '',
	#		description => '',
	#		failed => 0,
	#	},
	#	kfocus => {
	#		name => 'kfocus',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'NOKFOCUS',
	#		description => '',
	#		failed => 0,
	#	},
	#	tuxedo => {
	#		name => 'tuxedo',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'NOTUXEDO',
	#		description => '',
	#		failed => 0,
	#	},
	#	manjaro => {
	#		name => 'manjaro',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'NOMANJARO',
	#		description => '',
	#		failed => 0,
	#	},
	#	aistation => {
	#		name => 'aistation',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'NOAISTATION',
	#		description => '',
	#		failed => 0,
	#	},
	#	bareboneclass => {
	#		name => 'barebone-class',
	#		version => 1,
	#		active => 0,
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'HASHWELL BROADWELL SKYLAKE KABYLAKE COFFEELAKE',
	#		description => '',
	#		failed => 0,
	#	},
	#	barebonegrub => {
	#		name => 'barebone-grub',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'NOGRUB 02GRUB',
	#		description => '',
	#		failed => 0,
	#	},
	#	audiofix => {
	#		name => 'audiofix',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'AUDIOFIX',
	#		description => '',
	#		failed => 0,
	#	},
	#	fingerprint => {
	#		name => 'fingerprint',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'FINGERPRINT',
	#		description => '',
	#		failed => 0,
	#	},
	#	threeg => {
	#		name => 'threeg',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'THREEG',
	#		description => '',
	#		failed => 0,
	#	},
	#	hybrid => {
	#		name => 'hybrid',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'DISCRETE HYBRID',
	#		description => '',
	#		failed => 0,
	#	},
	#	nvidiadriver => {
	#		name => 'nvidia-driver',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'NVIDIATUX NVIDIANOR',
	#		description => '',
	#		failed => 0,
	#	},
	#	bluetooth => {
	#		name => 'bluetooth',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => 'BLUETOOTH',
	#		description => '',
	#		failed => 0,
	#	},
	#	tuxedowallpapers => {
	#		name => 'tuxedo-wallpapers',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => '',
	#		description => '',
	#		failed => 0,
	#	},
	#	tuxedoplymouthone => {
	#		name => 'tuxedo-plymouth-one',
	#		version => 1,
	#		active => 0,
	#		blacklisted => 0,
	#		required => 0,
	#		hwid => 1,
	#		package => 0,
	#		fainame => '',
	#		description => '',
	#		failed => 0,
	#	},

	i8042fix => {
		name => 'i8042-fix',
		version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => '',
		description => 'Fix for no-keyboard-present after boot on XC1711',
		failed => 0,
    },
    nobootonbattery => {
        name => 'no-boot-on-battery',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => '',
		description => 'Fix for no-boot-on-battery on BA15',
		failed => 0,
    },
);



# inserts array values as kernel parameters if not present
# example: my $retval = insert_grub(\@kernel_parameters);
sub insert_grub {
    my $grubFH;
    my @grub_lines;
    my $parameters = shift;
    my $parameter;
	my $inserted = 0;

    if ( open $grubFH, "<", $grub_file) {
        while (<$grubFH>) {
            push (@grub_lines, $_);
        }
        close $grubFH;

        foreach( @grub_lines ) {
            if ( $_ =~ m/^GRUB_CMDLINE_LINUX_DEFAULT="/ ) {
                foreach $parameter ( @{$parameters} ) {
                    unless ( $_ =~ m/$parameter/ ) {
                        if ($_ =~ m/""/) {
                            $_ =~ s/^(GRUB_CMDLINE_LINUX_DEFAULT=".*)"\n/$1$parameter"\n/;
                            ++$inserted;
							$update_grub_trigger = 1;
                        } else {
                            $_ =~ s/^(GRUB_CMDLINE_LINUX_DEFAULT=".*)"\n/$1 $parameter"\n/;
                            ++$inserted;
							$update_grub_trigger = 1;
                        }
                    }
                }
            }
        }
    } else {
        print "no $grub_file present or unable to open the file for reading\n";
    }

    if ( open $grubFH, ">", $grub_file ) {
        print $grubFH @grub_lines;
        close ($grubFH);
    } else {
        print "no $grub_file present or unable to open the file for writing\n";
    }

    return $inserted;
}


# fills global variable $configuration with data from file in $configfile
# if there is no configfile then it is left empty
sub read_configfile {
	my $fh;
	my $shortname;
	if ( open $fh, '<', $configfile ) {
		while ( my $line=<$fh> ) {
			chomp $line;
			#print "$line\n";
			my ($name, @cols) = split /\s+/, $line;
			$shortname = $name;
			$shortname =~ s/[^a-zA-Z0-9]//g;
			#print "shortname: $shortname\n";
			#print "name: $name\n";
			#print "version: $cols[1]\n";
			@comp{qw(name version active blacklisted required hwid package)} = ($name, @cols);
			$configuration{$shortname} = { %comp };
		}
		close $fh;
	} else {
		warn "Could not open configfile: $configfile $!";
	}
}


# overwrites file from $configfile with data from $configuration
# if file cannot be written then nothing happens
sub write_configfile {
	my $fh;
	if ( open $fh, '>', $configfile ) {
		foreach my $name (sort keys %modules) {
			print $fh "$modules{$name}{name} $modules{$name}{version} ".
			"$modules{$name}{active} $modules{$name}{blacklisted} ".
			"$modules{$name}{required} $modules{$name}{hwid} $modules{$name}{package}\n";
		}
		close $fh;
	} else {
		warn "Can't write to $configfile $!";
	}
}


# searches the sysfs subdirectory for active monitor entries
# and returns them as an array
sub find_active_edids {
	my $cards_dir = '/sys/class/drm';
	my $dir_handle;
	my @edidfile;

	if ( !opendir ($dir_handle, $cards_dir)) {
		warn "Unable to open $cards_dir: $!\n";
		return @edidfile;
	}
	my @FILES = grep { $_ ne '.' && $_ ne '..' } readdir($dir_handle);
	foreach my $file (@FILES) {
		my $path = "$cards_dir/$file";
		if ( -d $path ) {
			my $enabledfile = "$path/enabled";
			if ( -e $enabledfile ) {
				open(FILE, $enabledfile);
				$_ = <FILE>;
				close(FILE);
				if ($_ =~ /enabled/) {
					#print "enabled found under $path\n";
					my $statusfile = "$path/status";
					if ( -e $statusfile ) {
						open(FILE2, $statusfile);
						$_ = <FILE2>;
						if ($_ =~ /connected/) {
							push @edidfile, "$path/edid";
						}
					}
				}
			}
		}
	}
	return @edidfile;
}


# gets valid edid files
# converts edid data into an array of hash references to modules
sub get_edid_data {
	my @edidfiles = find_active_edids();
	my @edid_refs;
	my $fh;
	my $file_content;
	foreach ( @edidfiles ) {
		if ( open $fh, '<', $_ ) {
			$file_content = do { local $/; <$fh> };
			close $fh;
			push @edid_refs, parse_edid($file_content);
		} else {
			warn "Could not open file $_ $!";
		}
	}

	# open $fh, '<', '/sys/class/drm/card0-HDMI-A-2/edid' or die "Can't open file $!\n";
	#my $file_content = do { local $/; <$fh> };
	#close $fh;
	# returns hashref to module
	#return parse_edid($file_content);

	# returns array of hash references to module
	return @edid_refs;
}


# check whether the module is required for the system
# checks only for hardware
sub check_requirements {
	my $fh;
	my $boardname_filename = "/sys/class/dmi/id/board_name";
	my $boardname;
	my $boardvendor_filename = "/sys/class/dmi/id/board_vendor";
	my $boardvendor;

	# these will be installed on all notebooks, always
	#	$modules{tuxedokeyboard}{required} = 1;
	#	$modules{tuxedoccwmi}{required} =1 ;
	#	$modules{tuxedocontrolcenter}{required} = 1;
	#	$modules{tuxedotouchpadfix}{required} = 1;

	if ( open $fh, "<", $boardvendor_filename ) {
		$boardvendor = <$fh>;
		close $fh;
		if ( open $fh, "<", $boardname_filename ) {

			$boardname = <$fh>;
			close $fh;
		#		if ( $boardvendor =~ m/TUXEDO/ ) {
		#			$modules{tuxedo}{required} = 1;
			### close the program if it is not TUXEDO???
			#		}
			#		if ($boardname =~ m/(P95_96_97Ex_Rx|PB50_70RF_RD_RC|P9XXRC)/) {
			#			$modules{tuxedoucsiccg}{required} = 1;
			#}
			#if ($boardname =~ m/(P95_96_97Ex_Rx|P9XXRC)/) {
			#	$modules{kfocus}{required} = 1;
			#}
			#unless ($boardname =~ m/(N150ZU|N151ZU|N150CU|N151CU)/) {
			#	$modules{manjaro}{required} = 1;
			#}
			#unless ($boardname =~ m/(P95_96_97Ex_Rx|PB50_70EF_ED_EC|PB50_70RF_RD_RC|P9XXRC|P7xxTM)/) {
			#	$modules{aistation}{required} = 1;
			#}
			#if ($boardname =~ m/(P65_67RS|P65_67RP|P65xRP|P67xRP|P65xH|P65_P67H)/) {
			#	$modules{barebonegrub}{required} = 1;
			#	$modules{barebonegrub}{fainame} = '02GRUB';
			#}
			#if ($boardname =~ m/(P95)/) {
			#	$modules{audiofix}{required} = 1;
			#}
			if ($boardname =~ m/(PB50_70DFx,DDx)/) {
				$modules{i8042fix}{required} = 1;
			}
			if ($boardname =~ m/(PF5PU1G)/) {
				$modules{nobootonbattery}{required} = 1;
			}
		} else {
			warn "Could not open $boardvendor_filename $!";
		}

	} else {
		warn "Could not open $boardname_filename $!";
	}
	#	my @edid = get_edid_data();
	#	foreach ( @edid ) {
	#		if ( $_ =~ m/SDC Model a029 Serial Number 0/ ) {
	#			$modules{tuxedooledbrt}{required} = 1;
	#		}
	#	}
	#
	#	# by default DESKTOP
	#	$modules{chassistype}{fainame} = 'DESKTOP';
	#	my $chassis_type_fn = '/sys/devices/virtual/dmi/id/chassis_type';
	#	if ( open $fh, "<", $chassis_type_fn ) {
	#		my $chassis_type = <fh>;
	#		close $fh;
	#		if ( $chassis_type =~ m/(9|10)/ ) {
	#			$modules{chassistype}{fainame} = 'LAPTOP';
	#		} else {
	#			my $battery_folder = '/proc/acpi/battery';
	#			if ( opendir $fh, $battery_folder ) {
	#				while (my $file = readdir($fh)) {
	#					next unless (-d "$battery_folder/$file");
	#					unless ( $file =~ m/(\.|\.\.)/ ) {
	#						#print "folder: $file\n";
	#						$modules{chassistype}{fainame} = 'LAPTOP';
	#					}
	#				}
	#			}
	#		}
	#		unless ( $modules{chassistype}{fainame} =~ m/LAPTOP/ ) {
	#			my $acpi_string = 'ACPI: Battery Slot';
	#			my $dmesg_output = `dmesg`;
	#			if ( $dmesg_output =~ m/$acpi_string/ ) {
	#				$modules{chassistype}{fainame} = 'LAPTOP';
	#			}
	#		}
	#	}
	#
	#	my @lsusb_output = `lsusb`;
	#	chomp @output;
	#	foreach my $line ( @output )
	#	{
	#		
	#	}

}



# print status from all packages
# in a nice formated output
sub list_status {
	my @arr = ( ['Name', 'Version', 'Active', 'Blacklisted', 'Required'] );
	my $name;

	foreach $name (sort keys %modules) {
		push(@arr,
			["$modules{$name}{name}",
			 "$modules{$name}{version}",
			 "$modules{$name}{active}",
			 "$modules{$name}{blacklisted}",
			 "$modules{$name}{required}"]);
	}
	for my $row (@arr) {
		format STDOUT =
@<<<<<<<<<<<<<<<<<<<<  @<<<<<<<<<<<<  @<<<<<<<<<<<<  @<<<<<<<<<<<<  @<<<<<<<<<<<<
		@$row
.
		write;
	}
}


# for keyboard not present on boot
# for XC1711 on all distributions
sub i8042fix() {
	my @kernel_parameters = ("i8042.nopnp");
	my $retval;
	print "doing i8042fix\n";
	$retval = insert_grub(\@kernel_parameters);
}


# for not being able to boot if system is on battery
# affects BA15
sub nobootonbattery() {
	my @kernel_parameters = ("iommu=soft");
	my $retval;
	print "doing nobootonbattery\n";
	$retval = insert_grub(\@kernel_parameters);
}


# traverses the modules hash and starts the subroutine in the list
# if conditions as noted in the list are met
# not active, not blacklisted, required
sub apply_all_fixes {
	my $state = shift;		# configure or reconfigure
	my $key;
	my $exit_status;
	foreach $key (keys %modules) {
		print "key: $key\n";
		if ( installable($key, $state) ne "" ) {
			$key->();
		}
	}
	update_grub();
}


# call system update-grub
sub update_grub {
	my $exit_status;
	if ($update_grub_trigger) {
		$exit_status = system("update-grub");
		if ( $exit_status == 0 ) {
			print "error starting update-grub\n";
		}
	}
}


# checks if some module can be installed
# requires module key and wether configure or reconfigure
sub installable {
	my $key = shift;
	my $state = shift;
	print "key: $key state: $state\n";
	if ( $modules{$key}{active} eq '0' &&
   		 $modules{$key}{blacklisted} eq '0' &&
		 $modules{$key}{required} eq '0'  &&
		 $state eq 'configure') {
		print "configure\n";
		return $key;
	} elsif ( $modules{$key}{active} eq '1' &&
        	  $modules{$key}{blacklisted} eq '0' &&
        	  $modules{$key}{required} eq '1'  &&
        	  $state eq 'reconfigure') {
		print "reconfigure\n";
		return $key;
	} else {
		return "";
	}

}


# get sub name from %modules list from given module name
sub get_sub_name {
	my $key;
	foreach $key ( keys %modules ) {
		if ( $ARGV[1] eq $modules{$key}{name} ) {
			return $key;
		}
	}
	# return empty string if module is not found
	return "";
}


# when configure is selected
# configures requested module or all
# requires module name or "all" as parameters
sub configure {
	my $state = shift;		# configure or reconfigure
	my $key;
	if ($ARGV[1]) {
		if ($ARGV[1] eq 'all') {
			print "configure all\n";
			check_requirements();
			apply_all_fixes($state);
		} else {
			$key = get_sub_name();
			if ( $key ne "" ) {
				check_requirements();
				if ( installable($key, $state) ne "" ) {
					print "configure $key\n";
					$key->();
					update_grub();
				}
			} else {
				print "wrong module name\n";
			}
		}
	} else {
		print "undefined module name\n";
	}
}


# show description of module
sub module_description() {
	my $key;
	if ($ARGV[1]) {
		$key = get_sub_name();
		if ( $key ne "" ) {
            print "$modules{$key}{description}\n";
		} else {
			print "module: $ARGV[1] is not in the modules list\n";
		}
    } else {
		print "missing module name\n";
	}
}

# text to print for help
my $USAGE =<<USAGE;
tuxedo-tomte {COMMAND}
  list                        List all modules with detailed status
  description MODULE          Shows the description of the module
  configure MODULE ...|all    Configure an unconfigured module
  reconfigure MODULE...|all   Reconfigure a configured module
  remove MODULE...|ALL        Remove a configured module
  blacklist MODULE ...        Blacklist a module
  unblacklist MODULE ...      Unblacklist a module
  FAI                         For installation with FAI
  help                        Prints this message
USAGE

# prints help
sub help {
	print "$USAGE\n";
	exit 0;
}

# just for debug, delete afterwards
#print Dumper \%modules;

#list_status();
#write_configfile();
#read_configfile();

#my @edid_data = get_edid_data();
#print Dumper @edid_data;

#print Dumper \%configuration;


# define for each argvalues procedures
# modify $USAGE if any modifications here
if (defined $ARGV[0]) {
	if ($ARGV[0] eq "list") {
		list_status();
	} elsif ($ARGV[0] eq "FAI") {
		warn "Starting tuxedo-tomte in FAI modus\n";
	} elsif ($ARGV[0] eq "configure") {
		print "configure\n";
		configure("configure");
	} elsif ($ARGV[0] eq "remove") {
		print "remove, does nothing yet\n";
	} elsif ($ARGV[0] eq "reconfigure") {
		configure("reconfigure");
	} elsif ($ARGV[0] eq "blacklist") {
		print "blacklist, does nothing yet\n";
	} elsif ($ARGV[0] eq "unblacklist") {
		print "unblacklist, does nothing yet\n";
	} elsif ($ARGV[0] eq "description") {
		module_description();
	} elsif ($ARGV[0] eq "help") {
		help();
	} else {
		print "Unknown command: $ARGV[0]\n";
		help();
	}
} else {
	print "No arguments\n";
	help();
}


