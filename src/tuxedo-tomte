#!/usr/bin/perl -w
use strict;
use warnings;

# just for debug, delete afterwards
use Data::Dumper qw(Dumper);

# for OLED backlight and edid decrypt
use FindBin qw($Bin);
use lib "$Bin/.";
use Parse::EDID qw(parse_edid);

### configfile muss noch ins etc
my $configfile = '/home/pablo/tomte.cfg';
# definition loaded from configfile
my %configuration;
my %comp;

###############################################################################
# initial definition of all modules/packages
#   name        name of package or name of solution
#   version     the package or solution version
#   active      0 not installed / 1 installed
#   blacklisted   will not be configured on upgrade, install or deinstall
#   required    the system requirements are met
#   hwid        the environment (HW or SW) are in a certain defined state
#   package     there is a deb or rpm package to solve this problem
#   fainame     the name to give to FAI to install a certain package

my %modules = (
    tuxedokeyboard => {
        name => 'tuxedo-keyboard',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 1,
        fainame => 'a',
    },
    tuxedoccwmi => {
        name => 'tuxedo-cc-wmi',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 1,
        fainame => '',
    },
    tuxedocontrolcenter => {
        name => 'tuxedo-control-center',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 1,
        fainame => '',
    },
    tuxedoxpxcairplanemodefix => {
        name => 'tuxedo-xp-xc-airplane-mode-fix',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 1,
        fainame => 'AIRPLANEFIX NOGRUB',
    },
    tuxedorestoreaudiofix => {
        name => 'tuxedo-restore-audio-fix',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 1,
        fainame => 'AUDIORESTOREFIX',
    },
    tuxedoucsiccg => {
        name => 'tuxedo-ucsi_ccg',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 1,
        fainame => 'TUXUCIFIX',
    },
    tuxedooledbrt => {
        name => 'tuxedo-oled-brt',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 1,
        fainame => 'TUXOLED',
    },
    chassistype => {
        name => 'chassis-type',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => '',
    },
    barebone => {
        name => 'barebone',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => '',
    },
    kfocus => {
        name => 'kfocus',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'NOKFOCUS',
    },
    tuxedo => {
        name => 'tuxedo',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'NOTUXEDO',
    },
    manjaro => {
        name => 'manjaro',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'NOMANJARO',
    },
    aistation => {
        name => 'aistation',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'NOAISTATION',
    },
    bareboneclass => {
        name => 'barebone-class',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'HASHWELL BROADWELL SKYLAKE KABYLAKE COFFEELAKE',
    },
    i915class => {
        name => 'i915-class',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'NOI915',
    },
    barebonegrub => {
        name => 'barebone-grub',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'NOGRUB 02GRUB',
    },
    audiofix => {
        name => 'audiofix',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'AUDIOFIX',
    },
    fingerprint => {
        name => 'fingerprint',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'FINGERPRINT',
    },
    threeg => {
        name => 'threeg',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'THREEG',
    },
    hybrid => {
        name => 'hybrid',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'DISCRETE HYBRID',
    },
    nvidiadriver => {
        name => 'nvidia-driver',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'NVIDIATUX NVIDIANOR',
    },
    bluetooth => {
        name => 'bluetooth',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => 'BLUETOOTH',
    },
    tuxedowallpapers => {
        name => 'tuxedo-wallpapers',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => '',
    },
    tuxedoplymouthone => {
        name => 'tuxedo-plymouth-one',
        version => 1,
        active => 0,
        blacklisted => 0,
        required => 0,
        hwid => 1,
        package => 0,
        fainame => '',
    },
);


# fills global variable $configuration with data from file in $configfile
# if there is no configfile then it is left empty
sub read_configfile {
    my $fh;
    my $shortname;
    if ( open $fh, '<', $configfile ) {
        while ( my $line=<$fh> ) {
            chomp $line;
            #print "$line\n";
            my ($name, @cols) = split /\s+/, $line;
            $shortname = $name;
            $shortname =~ s/[^a-zA-Z0-9]//g;
            #print "shortname: $shortname\n";
            #print "name: $name\n";
            #print "version: $cols[1]\n";
            @comp{qw(name version active blacklisted required hwid package)} = ($name, @cols);
            $configuration{$shortname} = { %comp };
        }
        close $fh;
    } else {
        warn "Could not open configfile: $configfile $!";
    }
}


# overwrites file from $configfile with data from $configuration
# if file cannot be written then nothing happens
sub write_configfile {
    my $fh;
    if ( open $fh, '>', $configfile ) {
        foreach my $name (sort keys %modules) {
            print $fh "$modules{$name}{name} $modules{$name}{version} ".
            "$modules{$name}{active} $modules{$name}{blacklisted} ".
            "$modules{$name}{required} $modules{$name}{hwid} $modules{$name}{package}\n";
        }
        close $fh;
    } else {
        warn "Can't write to $configfile $!";
    }
}


# searches the sysfs subdirectory for active monitor entries
# and returns them as an array
sub find_active_edids {
    my $cards_dir = '/sys/class/drm';
    my $dir_handle;
    my @edidfile;

    if ( !opendir ($dir_handle, $cards_dir)) {
        warn "Unable to open $cards_dir: $!\n";
        return @edidfile;
    }
    my @FILES = grep { $_ ne '.' && $_ ne '..' } readdir($dir_handle);
    foreach my $file (@FILES) {
        my $path = "$cards_dir/$file";
        if ( -d $path ) {
            my $enabledfile = "$path/enabled";
            if ( -e $enabledfile ) {
                open(FILE, $enabledfile);
                $_ = <FILE>;
                close(FILE);
                if ($_ =~ /enabled/) {
                    #print "enabled found under $path\n";
                    my $statusfile = "$path/status";
                    if ( -e $statusfile ) {
                        open(FILE2, $statusfile);
                        $_ = <FILE2>;
                        if ($_ =~ /connected/) {
                            push @edidfile, "$path/edid";
                        }
                    }
                }
            }
        }
    }
    return @edidfile;
}


# gets valid edid files
# converts edid data into an array of hash references to modules
sub get_edid_data {
    my @edidfiles = find_active_edids();
    my @edid_refs;
    my $fh;
    my $file_content;
    foreach ( @edidfiles ) {
        if ( open $fh, '<', $_ ) {
            $file_content = do { local $/; <$fh> };
            close $fh;
            push @edid_refs, parse_edid($file_content);
        } else {
            warn "Could not open file $_ $!";
        }
    }

    #open my $fh, '<', '/sys/class/drm/card0-HDMI-A-2/edid' or die "Can't open file $!\n";
    #my $file_content = do { local $/; <$fh> };
    #close $fh;
    # returns hashref to module
    #return parse_edid($file_content);

    # returns array of hash references to module
    return @edid_refs;
}


# check whether the module is required for the system
sub check_requirements {
    my $fh;
    my $boardname_filename = "/sys/devices/virtual/dmi/id/board_name";
    
    # these will be installed on all notebooks, always
    $modules{tuxedokeyboard}{required} = 1;
    $modules{tuxedoccwmi}{required} =1 ;
    $modules{tuxedocontrolcenter}{required} = 1;
    $modules{tuxedotouchpadfix}{required} = 1;

    # check everything that needs the boardname
    if ( open $fh, "<", $boardname_filename ) {
        my $boardname = <$fh>;

        if ($boardname =~ m/(P95_96_97Ex_Rx|PB50_70EF_ED_EC|PB50_70RF_RD_RC|P9XXRC)/)
        {
            #print "setting tuxedoxpxcairplanemodefix required\n";
            $modules{tuxedoxpxcairplanemodefix}{required} = 1;
        }
        if ($boardname =~ m/(N350TW)/)
        {
            #print "setting tuxedorestoreaudiofix required\n";
            $modules{tuxedorestoreaudiofix}{required} = 1;
        }
        if ($boardname =~ m/(P95_96_97Ex_Rx|P9XXRC)/)
        {
            #print "setting tuxedoaudiofix required\n";
            $modules{tuxedoaudiofix}{required} = 1;
        }
        if ($boardname =~ m/(P95_96_97Ex_Rx|PB50_70RF_RD_RC|P9XXRC)/)
        {
            #print "setting tuxedoucsiccg required\n";
            $modules{tuxedoucsiccg}{required} = 1;
        }

        close $fh;
    } else {
        warn "Could not open $boardname_filename $!";
    }
    my @edid = get_edid_data();
    foreach ( @edid ) {
        if ( $_ =~ m/SDC Model a029 Serial Number 0/ ) {
            $modules{tuxedooledbrt}{required} = 1;
        }
    }

    # by default DESKTOP
    $modules{chassistype}{fainame} = 'DESKTOP';
    my $chassis_type_fn = '/sys/devices/virtual/dmi/id/chassis_type';
    if ( open $fh, "<", $chassis_type_fn ) {
        my $chassis_type = <fh>;
        close $fh;
        if ( $chassis_type =~ m/(9|10)/ ) {
            $modules{chassistype}{required} = 1;
            $modules{chassistype}{fainame} = 'LAPTOP';
        } else {
            my $battery_folder = '/proc/acpi/battery';
            if ( opendir $fh, $battery_folder ) {
                while (my $file = readdir($fh)) {
                    next unless (-d "$battery_folder/$file");
                    unless ( $file =~ m/(\.|\.\.)/ ) {
                        #print "folder: $file\n";
                        $modules{chassistype}{fainame} = 'LAPTOP';
                    }
                }
            }
        }
        unless ( $modules{chassistype}{fainame} =~ m/LAPTOP/ ) {
            my $acpi_string = 'ACPI: Battery Slot';
            my $dmesg_output = `dmesg`;
            if ( $dmesg_output =~ m/$acpi_string/ ) {
                $modules{chassistype}{fainame} = 'LAPTOP';
            }
        }
    }


}


# print status from all packages
# in a nice formated output
sub list_status {
    my @arr = ( ['Name', 'Version', 'Active', 'Blacklisted', 'Required'] );

    foreach my $name (sort keys %modules) {
        push(@arr,
            ["$modules{$name}{name}",
             "$modules{$name}{version}",
             "$modules{$name}{active}",
             "$modules{$name}{blacklisted}",
             "$modules{$name}{required}"]);
    }
    for my $row (@arr) {
        format STDOUT =
@<<<<<<<<<<<<<<<<<<<<  @<<<<<<<<<<<<  @<<<<<<<<<<<<  @<<<<<<<<<<<<  @<<<<<<<<<<<<
        @$row
.
        write;
    }
}


# text to print for help
my $USAGE =<<USAGE;
tuxedo-tomte {COMMAND}

  list                        List all modules with detailed status
  configure MODULE ...        Configure an unconfigured module
  reconfigure MODULE...|ALL   Reconfigure a configured module
  remove MODULE...|ALL        Remove a configured module
  blacklist MODULE ...        Blacklist a module
  unblacklist MODULE ...      Unblacklist a module
  FAI                         For installation with FAI\
  help                        Prints this message

USAGE


# prints help
sub help {
    print "$USAGE\n";
    exit 0;
}

# just for debug, delete afterwards
#print Dumper \%modules;

list_status();
write_configfile();
read_configfile();

my @edid_data = get_edid_data();
print Dumper @edid_data;

#print Dumper \%configuration;


# define for each argvalues procedures
if (defined $ARGV[0]) {
    if ($ARGV[0] eq "list") {
        list_status();
    } elsif ($ARGV[0] eq "FAI") {
        warn "Starting tuxedo-tomte in FAI modus\n";
    } elsif ($ARGV[0] eq "configure") {
        print "configure\n";
    } elsif ($ARGV[0] eq "remove") {
        print "remove\n";
    } elsif ($ARGV[0] eq "reconfigure") {
        print "reconfigure\n";
    } elsif ($ARGV[0] eq "blacklist") {
        print "blacklist\n";
    } elsif ($ARGV[0] eq "unblacklist") {
        print "unblacklist\n";
    } elsif ($ARGV[0] eq "help") {
        help();
    } else {
        print "Unknown command: $ARGV[0]";
        help();
    }
} else {
    print "No arguments\n";
    help();
}


